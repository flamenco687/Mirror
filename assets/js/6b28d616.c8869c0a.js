"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[936],{46859:function(e){e.exports=JSON.parse('{"functions":[{"name":"ListenToReflexUpdates","desc":"Makes passed reflex to start listening to value changes, child additions\\nand ancestry changes so server-mirror values can be replicated to the\\nclient mirror through reflexes.","params":[{"name":"Reflex","desc":"","lua_type":"Instance | Types.Reflex"},{"name":"Table","desc":"","lua_type":"Proxy"}],"returns":[],"function_type":"static","realm":["Client"],"private":true,"source":{"line":52,"path":"src/init.lua"}},{"name":"ValueChanged","desc":"Listens to reflex value changes and updates the [Mirror.Data] entry accordingly\\n\\n:::info Listener\\nThis function is a listener function that is activated when [Mirror.ListenToReflexUpdates]\\nis called and stops listening when the reflex which updates are being tracked is destroyed\\n\\n\\n    ","params":[],"returns":[],"function_type":"static","tags":["Listener"],"realm":["Client"],"private":true,"source":{"line":76,"path":"src/init.lua"}},{"name":"ChildAdded","desc":"Listens to reflex child additions. When a child is added to a reflex, it means that the reflex\\nreal value is now a table and the children are its entry values. Reflex\'s children listeners\\nare initiated on creation just as the parent reflex listeners were initiated too.\\n\\n:::info Listener\\nThis function is a listener function that is activated when [Mirror.ListenToReflexUpdates]\\nis called and stops listening when the reflex which updates are being tracked is destroyed\\n\\n\\n    ","params":[{"name":"Child","desc":"","lua_type":"Instance | Types.Reflex"}],"returns":[],"function_type":"static","tags":["Listener"],"realm":["Client"],"private":true,"source":{"line":101,"path":"src/init.lua"}},{"name":"Destroyed","desc":"Listens to reflex ancestry changes to check if the reflex no longer exists and to\\ndisconnect its connections if it is the case\\n\\n:::info Listener\\nThis function is a listener function that is activated when [Mirror.ListenToReflexUpdates]\\nis called and stops listening when the reflex which updates are being tracked is destroyed\\n\\n\\n    ","params":[{"name":"Child","desc":"","lua_type":"Instance"},{"name":"Parent","desc":"","lua_type":"Instance | nil"}],"returns":[],"function_type":"static","tags":["Listener"],"realm":["Client"],"private":true,"source":{"line":129,"path":"src/init.lua"}},{"name":"OnServerKeyChange","desc":"Fires when a key is changed on the server\'s [Mirror.Data]. The function updates\\nthe reflex equivalent of the key and triggers the whole replication process\\nby updating its value, connecting listeners and destroying old children","params":[{"name":"Key","desc":"","lua_type":"string"},{"name":"Value","desc":"","lua_type":"any"},{"name":"OldValue","desc":"","lua_type":"any"},{"name":"self","desc":"","lua_type":"Proxy"}],"returns":[],"function_type":"static","realm":["Server"],"private":true,"source":{"line":154,"path":"src/init.lua"}},{"name":"TableToProxy","desc":"Converts a vanilla table into a proxy object that is able to detect key\\nchanges. Proxies serve the purpose of detecting value changes from the\\nserver so they can be replicated through reflexes to the client.","params":[{"name":"Table","desc":"","lua_type":"table"},{"name":"Recursive","desc":"","lua_type":"boolean"},{"name":"Container","desc":"","lua_type":"Instance"}],"returns":[{"desc":"","lua_type":"Proxy\\r\\n"}],"function_type":"static","private":true,"source":{"line":175,"path":"src/init.lua"}},{"name":"AddWhitelist","desc":"Adds player or array of players to the [Mirror._Whitelist]","params":[{"name":"PlayerToAdd","desc":"","lua_type":"Player | Array<Player>"}],"returns":[],"function_type":"method","realm":["Server"],"source":{"line":214,"path":"src/init.lua"}},{"name":"RemoveWhitelist","desc":"Removes player or array of players from the [Mirror._Whitelist]","params":[{"name":"PlayerToRemove","desc":"","lua_type":"Player | Array<Player>"}],"returns":[],"function_type":"method","realm":["Server"],"source":{"line":227,"path":"src/init.lua"}},{"name":"Set","desc":"Overrides the current [Mirror.Data] and sets it to the passed table","params":[{"name":"NewData","desc":"","lua_type":"table"}],"returns":[],"function_type":"method","realm":["Server"],"source":{"line":250,"path":"src/init.lua"}},{"name":"Get","desc":"Returns an existing mirror","params":[{"name":"Name","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"Mirror\\r\\n"}],"function_type":"static","yields":true,"source":{"line":268,"path":"src/init.lua"}},{"name":"new","desc":"Constructs a new mirror\\n\\n:::caution\\nThe constructor function is used by both client and server but it should only directly be called\\nby the server to create new mirrors. The client will automatically retrieve all mirror settings\\nand construct the mirror internally when requesting a mirror with [Mirror.Get]","params":[{"name":"Name","desc":"","lua_type":"string"},{"name":"Origin","desc":"Optional table to work as a base for the mirror\'s [Mirror.Data]","lua_type":"table?"},{"name":"Settings","desc":"Additional settings such as whitelist, visibility...","lua_type":"MirrorSettings?"}],"returns":[{"desc":"","lua_type":"Mirror\\r\\n"}],"function_type":"static","tags":["Constructor"],"source":{"line":302,"path":"src/init.lua"}},{"name":"RequestRealValue","desc":"Returns the real value of the requested reflex. The function automatically checks if the\\nrequested reflex exists or is valid and if the player that requested the value is in the\\nreflex\'s mirror whitelist (in case the mirror is private).\\n\\n\\n    ","params":[{"name":"Player","desc":"","lua_type":"Player"},{"name":"Reflex","desc":"","lua_type":"Types.Reflex"}],"returns":[{"desc":"","lua_type":"any\\r\\n"}],"function_type":"static","tags":["RemoteFunction"],"realm":["Server"],"private":true,"source":{"line":356,"path":"src/init.lua"}},{"name":"ReflexesToTable","desc":"Converts the equivalent values of a whole instance tree of reflexes into\\na vanilla table that can later be used as a proxy for [Mirror.Data]","params":[{"name":"Parent","desc":"","lua_type":"Instance"}],"returns":[{"desc":"","lua_type":"Dictionary<any>\\r\\n"}],"function_type":"static","tags":["Utility"],"realm":["Client"],"private":true,"source":{"line":15,"path":"src/Utility/Client/ReflexesToTable.lua"}},{"name":"DestroyChildren","desc":"Destroys all children of an Instance","params":[{"name":"Parent","desc":"","lua_type":"Instance"}],"returns":[{"desc":"","lua_type":"nil\\r\\n"}],"function_type":"static","tags":["Utility"],"realm":["Server"],"private":true,"source":{"line":12,"path":"src/Utility/Server/DestroyChildren.lua"}},{"name":"SetReflexValue","desc":"Sets a new value for the passed reflex. The function checks if the value type\\nis supported by attributes, in which case they are used. Otherwhise, the real\\nvalue is stored in the `NonSupportedValues` shared table and the attribute is\\nset to nil to indicate that the real value must be requested.\\n\\n:::danger\\nAll changes made to the reflex instance must be done after working with the\\n`NonSupportedValues` table, otherwise the client could receive a wrong value","params":[{"name":"Reflex","desc":"","lua_type":"Types.Reflex"},{"name":"Value","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Types.Reflex\\r\\n"}],"function_type":"static","tags":["Utility"],"realm":["Server"],"private":true,"source":{"line":25,"path":"src/Utility/Server/SetReflexValue.lua"}},{"name":"GetInstance","desc":"Looks for an existing instance with the given name or creates a new one\\nof the specified class if the caller is the server. The client will only\\nwait for the existance of the desired instance if a parent was specified.\\n\\n:::note\\nNo return type is specified since function can return any type of instance\\nand type check may freak out when working with this function if [Instance]\\nwas specified as the returned value type","params":[{"name":"Name","desc":"","lua_type":"string"},{"name":"Class","desc":"","lua_type":"string?"},{"name":"Parent","desc":"","lua_type":"Instance?"}],"returns":[],"function_type":"static","tags":["Utility"],"private":true,"source":{"line":21,"path":"src/Utility/Shared/GetInstance.lua"}}],"properties":[{"name":"Data","desc":"","lua_type":"Proxy","source":{"line":41,"path":"src/init.lua"}}],"types":[{"name":"NonSupportedValues","desc":"This type is only used by a shared table made to hold values which are not supported by attributes\\nand for such reason must be requested by the client through [RemoteFunction]","lua_type":"{[Reflex]: any}","source":{"line":28,"path":"src/Shared/NonSupportedValues.lua"}},{"name":"Reflex","desc":"Reflexes are containers that simply hold a value (using roblox attributes) in a studio-instance. The reflexes of a mirror\\nrepresent that mirror\'s [Mirror.Data] in an instance tree so the client can easily access primitive values by making\\nuse of `:GetAttribute()`. If a reflex\'s value is nil it means that the real value is being held by the server because\\nit cannot be set as an attribute value.","lua_type":"Configuration","source":{"line":32,"path":"src/Types/init.lua"}},{"name":"MirrorSettings","desc":"","fields":[{"name":"Whitelist","lua_type":"{[number]: Player}?","desc":""},{"name":"IsPrivate","lua_type":"boolean?","desc":""}],"source":{"line":37,"path":"src/Types/init.lua"}}],"name":"Mirror","desc":"","source":{"line":36,"path":"src/init.lua"}}')}}]);